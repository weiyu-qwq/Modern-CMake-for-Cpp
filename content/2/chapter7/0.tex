It doesn't really matter whether your solution is big or small; as it matures, you'll eventually decide to bring in external dependencies. It's important to avoid the costs of creating and maintaining code using prevailing business logic. This way, you can devote your time to things that matter to you and your customers.

External dependencies are used not only to provide frameworks and features and solve quirky problems. They can also play an important part in the process of building and controlling the quality of your code – whether it is in the form of special compilers such as Protobuf or testing frameworks such as GTest.

Whether you're working with open source projects or using projects written by other developers in your company, you still need a good, clean process to manage external dependencies. Solving this on your own would take countless hours of setup and a lot of additional support work later. Fortunately, CMake does an excellent job in accommodating different styles and historical approaches to dependency management while keeping up with the constant evolution of industry-approved standards.

To supply an external dependency, we should first check whether the host system already has the dependency available, since it's best to avoid unnecessary downloads and lengthy compilations. We'll explore how to find and turn such dependencies into CMake targets to use in our project. This can be done in many ways, specifically when packages support CMake out of the box or at least provide files for a slightly older PkgConfig tool. If that's not the case, we can still write our own file to detect and include such a dependency.

We'll discuss what to do when a dependency isn't present on a system. As you can imagine, we can take alternative steps to automatically provide the necessary files. We'll consider tackling this problem using different Git methods and bringing in entire CMake projects as part of our build.

本章中，我们将讨论以下主题:

\begin{itemize}
\item 
How to find installed packages

\item 
Discovering legacy packages with FindPkgConfig0

\item 
Writing your own find-modules

\item 
Working with Git repositories

\item 
Using ExternalProject and FetchContent modules
\end{itemize}
