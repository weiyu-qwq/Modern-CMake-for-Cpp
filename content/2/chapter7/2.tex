Alright, let's say that you have decided to up your game with network communication or storing data at rest. Plaintext files, JSON, or even good old XML won't do. You want to serialize your data straight to binary format, preferably with a library known very well in the industry – say, protocol buffers (Protobuf) from Google. You find the documentation, install the dependencies in the system, and now what? How do we actually tell CMake to find and use this external dependency you're introducing? Luckily, there's a find\_package() command. It works like a charm in most cases.

Let's rewind and start by setting the scene – we have to install the dependencies we want to use because find\_package(), as the name suggests, is only about discovering packages in a system. We're assuming that dependencies are already installed or that users of our solution know how to install specific, necessary dependencies when prompted. To cover other scenarios, you'll need to provide a backup plan (more on which can be found in the Working with Git repositories section).

In the case of Protobuf, the situation is fairly straightforward: you can either download, compile, and install the library yourself from the official repository (\url{https://github.com/protocolbuffers/protobuf}) or use the package manager in your operating system. If you're following these examples using the Docker image mentioned in Chapter 1, First Steps with CMake, you'll be using Debian Linux. The commands to install the Protobuf library and compiler are as follows:

\begin{tcblisting}{commandshell={}}
$ apt update
$ apt install protobuf-compiler libprotobuf-dev
\end{tcblisting}

Every system has its own way of installing packages and managing them. Finding the path where a package is residing can be tricky and time-consuming, especially when you want to support most of the operating systems used today. Fortunately, find\_package() can often do it for you if the package in question provides an appropriate config-file that allows CMake to determine variables necessary to support the package.

Today, many projects are compatible with this requirement and provide this file for CMake during installation. If you plan to use some popular library that doesn't provide it, don't worry just yet. Chances are that CMake authors have bundled the file with CMake itself (these are called find-modules, to differentiate from config-files). If that's not the case, we still have some options:

\begin{itemize}
\item 
Provide our own find-modules for a specific package and bundle it with our project.

\item 
Write a config-file and ask package maintainers to ship the package with it.
\end{itemize}

You might say that you're not quite ready to create such merge requests yourself, and that's fine because it's most likely you won't have to. CMake ships with over 150 find-modules that can find libraries such as Boost, bzip2, curl, curses, GIF, GTK, iconv, ImageMagick, JPEG, Lua, OpenGL, OpenSSL, PNG, PostgreSQL, Qt, SDL, Threads, XML-RPC, X11, and zlib, and luckily, also the Protobuf file that we're going to use in this example. A full list is available in the CMake documentation: \url{https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html\#find_modules}.

Both find-modules and config-files can be used in CMake projects with a single find\_package() command. CMake looks for matching find-modules, and if it can't find any, it will turn to config-files. The search will start from the path stored in the CMAKE\_MODULE\_PATH variable (which is empty by default). This variable can be configured by a project when it wants to add and use external find-modules. Next, CMake will scan the list of built-in find-modules available in the installed version of CMake.

If no applicable module is found, it's time to search for corresponding package config-files. CMake has a long list of paths appropriate for a host operating system, which can be scanned for filenames matching the following pattern:

\begin{itemize}
\item 
<CamelCasePackageName>Config.cmake

\item 
<kebab-case-package-name>-config.cmake
\end{itemize}

Let's talk a little about the project files; in this example, I don't really intend to design a full network-based solution with remote procedure calls and all the bells and whistles. Instead, I just want to prove that I can build and run a project that depends on Protobuf. To accomplish this, I'm going to create a .proto file with as small a contract as possible. If you're not that familiar with Protobuf, just know that this library provides a mechanism to serialize structured data in a binary form. To do so, we need to provide a schema of such a structure, which will be used to write and read from binary form into C++ objects.

This is what I came up with:

\begin{lstlisting}[style=styleCXX]
// chapter07/01-find-package-variables/message.proto

syntax = "proto3";
message Message {
	int32 id = 1;
}
\end{lstlisting}

Don't worry if you're not familiar with Protobuf syntax (this isn't really what this example is about). This is just a simple message that contains just one 32-bit integer. Protobuf has a special compiler that will read these files and generate C++ sources and headers that can be then used by our application. This means we'll need to somehow add this compilation step to our process. We'll return to that. For now, let's see what our main.cpp file looks like:

\begin{lstlisting}[style=styleCXX]
//chapter07/01-find-package-variables/main.cpp

#include "message.pb.h"
#include <fstream>
using namespace std;
int main()
{
	Message m;
	m.set_id(123);
	m.PrintDebugString();
	fstream fo("./hello.data", ios::binary | ios::out);
	m.SerializeToOstream(&fo);
	fo.close();
	return 0;
}
\end{lstlisting}

As I've mentioned, Message contains a single id field. In the main.cpp file, I'm creating an object representing this message, setting the field to 123, and printing its debug information to the standard output. Next, I'm creating a file stream, writing a binary version of this object to it, and closing the stream – the simplest possible use for a serialization library.

Note that I've included a message.pb.h header. This file doesn't yet exist; it needs to be created by protoc, the Protobuf compiler, during compilation of message.proto. This scenario sounds pretty complex, implying that the list file of such a project must be incredibly long. Not at all! This is where the CMake magic happens:

\begin{lstlisting}[style=styleCMake]
# chapter07/01-find-package-variables/CMakeLists.txt

cmake_minimum_required(VERSION 3.20.0)
project(FindPackageProtobufVariables CXX)

find_package(Protobuf REQUIRED)
protobuf_generate_cpp(GENERATED_SRC GENERATED_HEADER
	message.proto)

add_executable(main main.cpp
	${GENERATED_SRC} ${GENERATED_HEADER})
target_link_libraries(main PRIVATE ${Protobuf_LIBRARIES})
target_include_directories(main PRIVATE
	${Protobuf_INCLUDE_DIRS}
	${CMAKE_CURRENT_BINARY_DIR})
\end{lstlisting}

Let's break this down:

\begin{itemize}
\item 
The first two lines we know already; they create the project and declare its language

\item 
find\_package(Protobuf REQUIRED) asks CMake to run the bundled FindProtobuf.cmake find-module and set up the Protobuf library for us. That find-module will scan commonly used paths and (because we provided the REQUIRED keyword) terminate if a library is not found. It will also specify useful variables and functions (such as the one on the next line)

\item 
protobuf\_generate\_cpp is a custom function defined in the Protobuf findmodule. Under the hood, it calls add\_custom\_command(), which invokes the protoc compiler with appropriate arguments. We use this function by providing two variables that will be filled with paths to the generated source (GENERATED\_SRC) and header (GENERATED\_HEADER) files, and a list of files to compile (message.proto).

\item 
add\_executable, as we already know, will create our executable using main.cpp and Protobuf files configured in the previous command.

\item 
target\_link\_libraries adds libraries (static or shared) found by find\_package() to the linking command of our main target.

\item 
target\_include\_directories() adds to include paths the necessary INCLUDE\_DIRS provided by the package and CMAKE\_CURRENT\_BINARY\_DIR. The latter is needed so that the compiler can find the generated message.pb.h header.
\end{itemize}

In other words, it achieves the following:

\begin{itemize}
\item 
Finds the location of the library and the compiler

\item 
Provides helper functions to teach CMake how to call a custom compiler for .proto files

\item 
Adds variables containing the necessary paths for inclusion and linking
\end{itemize}

In most cases, you can expect some variables to be set when you call find\_package(), whether you're using a built-in find-module or a config-file bundled with a package (assuming that the package was found):

\begin{itemize}
\item 
<PKG\_NAME>\_FOUND

\item 
<PKG\_NAME>\_INCLUDE\_DIRS or <PKG\_NAME>\_INCLUDES

\item 
<PKG\_NAME>\_LIBRARIES or <PKG\_NAME>\_LIBRARIES or <PKG\_NAME>\_LIBS

\item 
<PKG\_NAME>\_DEFINITIONS

\item 
IMPORTED targets specified by the find-module or config-file
\end{itemize}

The last point is really interesting – if a package supports so-called "modern CMake" (built around targets), it will provide those IMPORTED targets instead (or alongside) of these variables, which allows for cleaner, simpler code. It is recommended to prioritize targets over variables.

Protobuf is a great example, as it offers both variables and IMPORTED targets (since CMake 3.10): protobuf::libprotobuf, protobuf::libprotobuf-lite, protobuf::libprotoc, and protobuf::protoc. This allows us to write even more concise code:

\begin{lstlisting}[style=styleCMake]
# chapter07/02-find-package-targets/CMakeLists.txt

cmake_minimum_required(VERSION 3.20.0)
project(FindPackageProtobufTargets CXX)

find_package(Protobuf REQUIRED)
protobuf_generate_cpp(GENERATED_SRC GENERATED_HEADER
	message.proto)

add_executable(main main.cpp
	${GENERATED_SRC} ${GENERATED_HEADER})
	
target_link_libraries(main PRIVATE protobuf::libprotobuf)
target_include_directories(main PRIVATE
${CMAKE_CURRENT_BINARY_DIR})
\end{lstlisting}

The protobuf::libprotobuf imported target implicitly specifies include directories and, thanks to transitive dependencies (or propagated properties as I call them), they are shared with our main target. The same process happens with the linker and compiler flags.

If you need to know what exactly is provided from a specific find-module, it's best to visit its online documentation. One for Protobuf can be found here: \url{https://cmake.org/ cmake/help/latest/module/FindProtobuf.html}.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Important Note]
To keep things simple, examples in this section will simply fail if the protobuf library (or its compiler) was not found in the user's system. But a really robust solution should verify that by checking the Protobuf\_FOUND variable and acting accordingly, either by printing a clear diagnostic message for the user (so they can install it) or performing the installation automatically.
\end{tcolorbox}

The last thing to mention about the find\_package() command is its options. A full list is a bit extensive, so we'll just focus on the basic signature. It looks like this:

\begin{lstlisting}[style=styleCMake]
find_package(<Name> [version] [EXACT] [QUIET] [REQUIRED])
\end{lstlisting}

The most important options are as follows:

\begin{itemize}
\item 
[version], which allows us to optionally request a specific version. Use the major.minor.patch.tweak format (such as 1.22) or provide a range – 1.22...1.40.1 (use three dots as a separator).

\item 
The EXACT keyword means that we want an exact version (a range is not supported here).

\item 
The QUIET keyword silences all messages about a found/not found package.

\item 
The REQUIRED keyword will stop execution if a package is not found and print a diagnostic message (even if QUIET is enabled).
\end{itemize}

More information on the command can be found on the documentation page here: \url{https://cmake.org/cmake/help/latest/command/find_package.html}.

The concept of providing config-files for a package that could be automatically consumed by buildsystems isn't that new. And it certainly wasn't invented by CMake. There are other tools and formats for this very purpose. PkgConfig is one of them. CMake provides a useful wrapper module to support it as well.





