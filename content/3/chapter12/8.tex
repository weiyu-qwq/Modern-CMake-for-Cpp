This chapter wraps up our long journey through CMake. Now you fully understand what problems CMake aims to solve and which steps are necessary to automate these solutions.

In the first three chapters, we explored all the basics: what CMake is and how users leverage it to bring raw source code to life, what the key components of CMake are, and what purpose different project files have. We explained the syntax of CMake: comments, command invocation, arguments, variables, and control structures. We've discovered how modules and subprojects work, what the correct project structure is, and how to work with various platforms and toolchains.

The second part of the book taught us about building with CMake: how to use targets, custom commands, build types, and generator expressions. We dove deep into the technicalities of compilation, and the configuration of a preprocessor and an optimizer. We discussed linking and introduced different library types. Then, we investigated how CMake helps to manage the dependencies of a project with the FetchContent and ExternalProject modules. We also researched Git submodules as a possible alternative. Most importantly, we studied how to find installed packages with find\_package() and FindPkgConfig. If these weren't enough, we looked into writing our own find-modules.

The last part told us how to go about the automation of testing, analysis, documentation, installing, and packaging. We looked into CTest and testing frameworks: Catch2, GoogleTest, and GoogleMock. Coverage reporting was covered too. Chapter 9, Program Analysis Tools, gave us an understanding of different analysis tools: a formatter and static checkers (Clang-Tidy, Cppcheck, and so on), and explained how to add the Memcheck memory analyzer from the Valgrind suite. Next, we briefly described how to generate documentation with Doxygen and how to make it presentable. Lastly, we demonstrated how to install projects on the system, create reusable CMake packages, and configure and use CPack to generate binary packages.

The last chapter drew on all this knowledge to showcase a completely professional project.

Congratulations on completing this book. We've covered everything necessary to develop, test, and package high-quality C ++ software. The best way to make progress from here is to put what you have learned into practice and create great software for your users. Good luck!

R.














