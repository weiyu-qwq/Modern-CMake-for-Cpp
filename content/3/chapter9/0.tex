即使对于非常有经验的开发人员来说，生成高质量的代码也不是一件容易的事情。通过向解决方案添加测试，降低了在业务代码中犯明显错误的风险。但这还不足以避免更复杂的问题。每一个软件都包含如此多的细节，以至于跟踪它们都成为了一项全职工作。维护产品的团队达成了几十种约定和多种特殊的设计实践。

有些问题与一致的编码风格有关:应该在代码中使用80列还是120列?是否应该允许std::bind或使用Lambda函数?是否可以使用C风格的数组?小函数应该在单行中定义吗?应该始终坚持使用auto，还是只在增加可读性时才使用?

理想情况下，还可以避免一般情况下已知不正确的语句:无限循环、使用标准库保留的标识符、无意的精度损失、冗余的if语句以及其他不被认为是“最佳实践”的语句(参见扩展阅读部分的参考资料)。

另一件需要关注的事情是代码的现代化:随着C++的发展，提供了新的特性。跟踪可以重构到最新标准的所有位置是很困难的。此外，手工工作会耗费太多时间，并引入了错误的风险，这对于大型代码库来说是相当大的风险。

最后，应该检查事物在启动时是如何工作的:执行程序并检查其内存。使用后是否正确释放内存?是否正确地访问了初始化的数据?或者代码试图解引用一些悬空指针?

手工管理所有这些问题是低效且容易出错的，可以使用自动实用程序来检查和执行规则，修复错误，并更新代码。是时候发现用于程序分析的工具了。代码将在每次构建时进行检查，以确保它符合行业标准。

本章中，我们将讨论以下主题:

\begin{itemize}
\item 
格式化

\item 
静态检查

\item 
Valgrind的动态分析
\end{itemize}













