"You'll spend more time studying the code than creating it – therefore, you should optimize for reading rather than writing."

This sentence is repeated like a mantra in more than one book discussing clean code practices. No wonder, as this is very true, as tested in practice by many software developers – so much so that rules for even minuscule things such as the numbers of spaces, newlines, and the ordering of \#import statements have been codified. This isn't done out of pettiness, but to save time. By following the practices outlined in this chapter, we don't need to worry about formatting code correctly by hand. It will automatically get formatted as a side effect of building – a step that we have to do anyway to check whether the code is working correctly. By introducing ClangFormat, we can also ensure that it looks proper.

Of course, we want more than a simple whitespace correction; code has to conform to dozens of other small regulations. This is done by the addition of Clang-Tidy and configuring it to enforce the coding style of our choosing. We discussed this static checker in detail, but we also mentioned other options: Cpplint, Cppcheck, Include-what-you-use, and Link-what-you-use. Since static linkers are relatively fast, we can add them to builds with little investment, and it will usually be well worth the price.

Lastly, we looked at the Valgrind utilities, specifically Memcheck, which allows debugging problems related to memory management: incorrect reads, writes, deallocations, and so on. This is a very handy tool that can save hours of manual investigation and prevent bugs from sneaking into production. As mentioned, it can be a bit slow to execute, which is why we created a separate target to run it explicitly before submitting the code. We also learned how to present the output of Valgrind in a more approachable form with Memcheck-Cover, an HTML report generator. This can be really useful in environments that don't support running an IDE (such as CI pipelines).

Of course, we aren't limited to these tools; there's plenty more: both free and open source projects, as well as commercial products coming with extensive support. This is merely an introduction to the subject. Be sure to explore what's right for you. In the next chapter, we'll take a closer look at documentation generation.
