Professional developers generally follow rules. They say that senior developers know when to break one (as they can justify the need to). On the other hand, it is said that very senior developers don't break rules because it's a waste of time having to keep explaining their reasons to others. I say, pick your battles and focus on things that actually matter and have a tangible impact on the product.

When it comes to coding style and formatting, programmers are presented with a myriad of choices: should we use tabs or spaces for indentation? If spaces, how many? What is the limit of characters in a column? How about in a file? Such choices don't impact the behavior of the program in most cases, but they do generate a lot of noise and start lengthy discussions that don't bring much value to a product.

Some practices are commonly agreed upon, but most of the time, we're debating personal preference and anecdotal evidence. After all, enforcing 80 characters in a column over 120 is an arbitrary choice. It doesn't really matter what we're going to choose as long as we're consistent. Inconsistency in style is bad, as it affects an important aspect of the software â€“ the readability of the code.

The best way to avoid it is to use a formatting tool such as clang-format. This can alert us that the code isn't formatted properly and even fix things that stand out if we let it.
Here's an example of a command that formats code:

\begin{tcblisting}{commandshell={}}
clang-format -i --style=LLVM filename1.cpp filename2.cpp
\end{tcblisting}

The -i option tells ClangFormat to edit files in place. -{}-style selects which supported formatting style should be used: LLVM, Google, Chromium, Mozilla, WebKit, or custom, provided from file (there are links to details in the Further reading section).
Of course, we don't want to execute this command manually every time we make a change; CMake should take care of this as part of the building process. We already know how to find clang-format in the system (we'll need to install it manually beforehand).

What we haven't discussed yet is the process of applying an external tool to all of our source files. To do it, we'll create a convenient function that can be included from the cmake directory:

\begin{lstlisting}[style=styleCMake]
# chapter09/01-formatting/cmake/Format.cmake

function(Format target directory)
	find_program(CLANG-FORMAT_PATH clang-format REQUIRED)
	set(EXPRESSION h hpp hh c cc cxx cpp)
	list(TRANSFORM EXPRESSION PREPEND "${directory}/*.")
	file(GLOB_RECURSE SOURCE_FILES FOLLOW_SYMLINKS
		LIST_DIRECTORIES false ${EXPRESSION}
	)
	add_custom_command(TARGET ${target} PRE_BUILD COMMAND
		${CLANG-FORMAT_PATH} -i --style=file ${SOURCE_FILES}
	)
endfunction()
\end{lstlisting}

The Format function takes two arguments: target and directory. It will format all source files from directory, right before target is built.

Technically, not all files in directory must necessarily belong to target (and target sources can potentially be in multiple directories). However, finding all the source files and headers that belong to the target (and possible dependent targets) is a very complex process, especially when we need to filter out headers that belong to external libraries and shouldn't be formatted. It's just more manageable to work on directories in this scenario. We can just call the function for each directory of the formatted target.

This function has the following steps:

\begin{enumerate}
\item 
Find the clang-format binary installed in the system. The REQUIRED keyword will stop the configuration with an error if the binary wasn't found.

\item 
Create a list of file extensions to format (to be used as a globbing expression).

\item 
Prepend each expression with a path to directory.

\item 
Recursively search for sources and headers (using the previously created list), skip directories, and put their paths into the SOURCE\_FILES variable.

\item 
Hook the formatting command as the PRE\_BUILD step of target.
\end{enumerate}

This command will work well for small-to-medium code bases. For high amounts of files, we'd need to transform absolute file paths to relative paths and execute formatting using directory as a working directory (the list(TRANSFORM) command is useful here). This might be necessary because commands passed to the shell have a limit on their length (usually about 13,000 characters) and too many long paths simply won't fit.

Let's see how we can use this function in practice. We'll use the following project structure:

\begin{tcblisting}{commandshell={}}
- CMakeLists.txt
- .clang-format
- cmake
    |- Format.cmake
- src
    |- CMakeLists.txt
    |- header.h
    |- main.cpp
\end{tcblisting}

First, we'll need to set up the project and add the cmake directory to the module path so that we can include it later:

\begin{lstlisting}[style=styleCMake]
# chapter09/01-formatting/CMakeLists.txt

cmake_minimum_required(VERSION 3.20.0)
project(Formatting CXX)
enable_testing()
list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
add_subdirectory(src bin)
\end{lstlisting}

Having that set, let's fill in the list file for the src directory:

\begin{lstlisting}[style=styleCMake]
# chapter09/01-formatting/src/CMakeLists.txt

add_executable(main main.cpp)
include(Format)
Format(main .)
\end{lstlisting}

This is simple and to the point. We have created an executable target main, included the Format.cmake module, and called the Format() function for the main target in the current directory (src).

Now, we need some unformatted source files. The header is just a simple unused function:

\begin{lstlisting}[style=styleCXX]
// chapter09/01-formatting/src/header.h

int unused() { return 2 + 2; }
\end{lstlisting}

We'll also add a source file with way too much whitespace:

\begin{lstlisting}[style=styleCXX]
// chapter09/01-formatting/src/main.cpp

#include <iostream>
using namespace std;
int main() {
	cout << "Hello, world!" << endl;
}
\end{lstlisting}

We're almost set. All that's left is the configuration file of the formatter (which is enabled with the -{}-style=file argument in the command line):

\begin{lstlisting}[style=stylePython]
# chapter09/01-formatting/.clang-format

BasedOnStyle: Google
ColumnLimit: 140
UseTab: Never
AllowShortLoopsOnASingleLine: false
AllowShortFunctionsOnASingleLine: false
AllowShortIfStatementsOnASingleLine: false
\end{lstlisting}

Clang Format will scan the parent directories for the .clang-format file, which specifies the exact formatting rules. This allows us to specify every little detail, or to customize one of the standards mentioned earlier. In my case, I've chosen to start with Google's coding style and throw in a few tweaks: limit columns to 140 characters, remove tabs, and allow short loops, functions, and if statements.

Let's see how files have changed after building this project (formatting happens automatically before compilation):

\begin{lstlisting}[style=styleCXX]
// chapter09/01-formatting/src/header.h (formatted)

int unused() {
	return 2 + 2;
}
\end{lstlisting}

The header file was formatted, even though it isn't used by the target; short functions aren't allowed on a single line. The formatter added new lines, just as expected. The main.cpp file also looks pretty slick now:

\begin{lstlisting}[style=styleCXX]
// chapter09/01-formatting/src/main.cpp (formatted)

#include <iostream>
using namespace std;
int main() {
	cout << "Hello, world!" << endl;
}
\end{lstlisting}

Unnecessary whitespace was removed and indentations were standardized.

Adding the automated formatter isn't too big of an effort and will save you a bunch of time in code reviews. If you've ever had to amend a commit to correct some whitespace, you know the feeling. Consistent formatting keeps your code neat without any effort.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Note]
Applying formatting to an existing code base will most likely introduce a big one-off change to the majority of the files in the repository. This may cause a lot of merge conflicts if you (or your teammates) have some ongoing work. It's best to coordinate such efforts to happen after all pending changes are done. If this isn't possible, consider gradual adoption, perhaps on a per-directory basis. Your fellow developers will thank you.
\end{tcolorbox}

The formatter is a great and simple tool to bring the visual aspect of the code together, but it isn't a fully fledged program analysis tool (it focuses mostly on whitespace). To deal with more advanced scenarios, we need to reach for utilities capable of understanding the program's source to perform a static analysis.