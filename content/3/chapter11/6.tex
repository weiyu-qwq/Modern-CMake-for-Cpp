Building projects from a source has its benefits, but it can take a long time and introduce a lot of complexity. This isn't the best experience for end users who just want to use the package, especially if they aren't developers themselves. A much more convenient form of software distribution is to use binary packages that contain compiled artifacts and other static files that are needed by the runtime. CMake supports generating multiple kinds of such packages through a command-line tool called cpack.

The following table lists the available package generators:

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Name} & \textbf{File Types} & \textbf{Platform}                         \\ \hline
		Archive &
		\begin{tabular}[c]{@{}l@{}}7Z - 7zip - (.7z)\\ TBZ2(.tar.bz2)\\ TGZ(.tar.gz)\\ TXZ(.tar.xz)\\ TZ(.tar.Z)\\ TZST(.tar.zst)\\ ZIP(.zip)\end{tabular} &
		Cross-platform \\ \hline
		Bundle        & Bundle(.bundle)     & macOS                                     \\ \hline
		DEB           & DEB(.deb)           & Linux                                     \\ \hline
		DragNDrop     & DMG(.dmg)           & macOS                                     \\ \hline
		External      & JSON(.json)         & Integration with external packaging tools \\ \hline
		FreeBSD       & PKG(pkg)            & *BSDï¼ŒLinux, OSX                           \\ \hline
		IFW           & Binary              & Linux, Windows, macOS                     \\ \hline
		NSIS          & Binary(.exe)        & Windows                                   \\ \hline
		NuGet         & NuGet(.nupkg)       & Windows                                   \\ \hline
		productbuild  & PKG(.pkg)           & macOS                                     \\ \hline
		RPM           & RPM(.rpm)           & Linux                                     \\ \hline
		WIX           & MSI(.msi)           & Windows                                   \\ \hline
	\end{tabular}
\end{table}

Most of these generators have extensive configurations. It is beyond the scope of this book to delve into all their details, so be sure to check out the full documentation, which can be found in the Further reading section. Instead, we'll focus on the general use case.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Note]
Package generators shouldn't be confused with buildsystem generators (Unix Makefiles, Visual Studio, and so on).
\end{tcolorbox}

To use CPack, we'll need to correctly configure the installation of our project with the necessary install() commands and build our project. The resulting cmake\_install.cmake that's generated in our build tree will be used by cpack to prepare binary packages based on the configuration file (CPackConfig.cmake). While it's possible to create this file manually, it's easier to use include(CPack) to include the utility module in our project's listfile. It will generate the configuration in the project's build tree and supply all the default values where needed.

Let's see how we can extend the example 11-components so that it can work with CPack:

\begin{lstlisting}[style=styleCMake]
# chapter-11/12-cpack/CMakeLists.txt (fragment)

cmake_minimum_required(VERSION 3.20.0)
project(CPackPackage VERSION 1.2.3 LANGUAGES CXX)
include(GNUInstallDirs)
add_subdirectory(src bin)

install(...)
install(...)
install(...)

set(CPACK_PACKAGE_VENDOR "Rafal Swidzinski")
set(CPACK_PACKAGE_CONTACT "email@example.com")
set(CPACK_PACKAGE_DESCRIPTION "Simple Calculator")
include(CPack)
\end{lstlisting}

The code is pretty self-explanatory, so we won't dwell on it too much (please refer to the module documentation, which can be found in the Further reading section). One thing worth noting here is the fact that the CPack module will infer a few values from the project() command:

\begin{itemize}
\item 
CPACK\_PACKAGE\_NAME

\item 
CPACK\_PACKAGE\_VERSION

\item 
CPACK\_PACKAGE\_FILE\_NAME
\end{itemize}

The last value will be used to produce the output package. Its structure is as follows:

\begin{lstlisting}[style=styleCMake]
$CPACK_PACKAGE_NAME-$CPACK_PACKAGE_VERSION-$CPACK_SYSTEM_NAME
\end{lstlisting}

Here, CPACK\_SYSTEM\_NAME is the name of the target OS; for example, Linux or win32. For example, by executing a ZIP generator on Debian, CPack will generate a file named CPackPackage-1.2.3-Linux.zip.

After building our project, we can generate actual packages by running the cpack binary in the build tree:

\begin{tcblisting}{commandshell={}}
cpack [<options>]
\end{tcblisting}

Technically speaking, CPack is capable of reading all its options from the configuration file that's been placed in the current working directory, but you may choose to override these settings from the command line:

\begin{itemize}
\item 
-G <generators>: This is a semicolon-separated list of package generators to use. The default value can be specified in the CPackConfig.cmake in the CPACK\_GENERATOR variable.

\item 
-C <configs>: This is a semicolon-separated list of build configurations (debug, release) to generate packages for (required for multi-configuration buildsystem generators).

\item 
-D <var>=<value>: This overrides a <var> variable that's set in the CPackConfig.cmake file with <value>

\item 
-{}-config <config-file>: This is the config-file you should use instead of the default CPackConfig.cmake.

\item 
-{}-verbose, -V: Provides verbose output.

\item 
-P <packageName>: Overrides the package name.

\item 
-R <packageVersion>: Overrides the package version.

\item 
-{}-vendor <vendorName>: Overrides the package vendor.

\item 
-B <packageDirectory>: Specifies the output directory for cpack (by default, this will be the current working directory).
\end{itemize}

Let's try generating packages for our 12-cpack output. We're going to use ZIP, 7Z, and the Debian package generator:

\begin{tcblisting}{commandshell={}}
cpack -G "ZIP;7Z;DEB" -B packages
\end{tcblisting}

The following packages should be generated:

\begin{itemize}
\item 
CPackPackage-1.2.3-Linux.7z

\item 
CPackPackage-1.2.3-Linux.deb

\item 
CPackPackage-1.2.3-Linux.zip
\end{itemize}

In this format, binary packages are ready to be published on the website of our project, in a GitHub release, or sent to a package repository for end users to enjoy.












