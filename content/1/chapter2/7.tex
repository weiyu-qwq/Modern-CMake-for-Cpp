This chapter opened the door to actual programming with CMake – you're now able to write great, informative comments and invoke built-in commands, and you understand how to correctly provide all kinds of arguments to them. This knowledge alone will help you understand the unusual syntax of CMake listfiles that you may have seen in other projects.

Next, we covered variables in CMake – specifically, how to reference, set, and unset normal, cache, and environment variables. We took a deep dive into how directory and function scopes work, and we discussed the issues (and their workarounds) relating to nested scopes.

We also covered lists and control structures. We discussed the syntax of conditions, their logical operations, the evaluation of unquoted arguments, and strings and variables. We learned how to compare values, do simple checks, and examine the state of the files in the system. This allows us to write conditional blocks and while loops. And while we were talking about loops, we also grasped the syntax of foreach loops.

I'm sure that knowing how to define your own commands with macro and function statements will help you write cleaner code in a more procedural style. We also shared a few ideas about how to structure our code better and come up with more readable names.

Finally, we were formally introduced to the message() command and its multiple log levels. We also studied how to partition and include listfiles, and we discovered a few other useful commands. I feel confident that with this material, we are ready to tackle the next chapter and write our first project in CMake.