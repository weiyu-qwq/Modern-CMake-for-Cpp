
As our solutions grow in the number of lines and files they have, we slowly understand that the inevitable is coming: either we start partitioning the project or we drown in lines of code and a multitude of files. We can approach this problem in two ways: by portioning the CMake code and by moving the source files to subdirectories. In both cases, we aim to follow the design principle called separation of concerns. Put simply, break your code into chunks, grouping code with closely related functionality while decoupling other pieces of code to create strong boundaries.

We talked a bit about partitioning CMake code when discussing listfiles in Chapter 1, First Steps with CMake. We spoke about the include() command, which allows CMake to execute the code from an external file. Calling include() doesn't introduce any scopes or isolations that are not defined within the file (if the included file contains functions, their scope will be handled correctly upon calling).

This method helps with separation of concerns, but only a little – specialized code is extracted to separate files and can even be shared across unrelated projects, but it can still pollute the global variable scope with its internal logic if the author is not careful. An old truth in programming is that even the worst mechanism is better than the best intentions.
We'll learn how to deal with this problem in a second, but for now, let's shift our focus to source code.

Let's consider an example of software that supports a small car rental company – it will have many source files defining different aspects of the software: managing customers, cars, parking spots, long-term contracts, maintenance records, employee records, and so on. If we were to put all of these files in a single directory, finding anything would be a nightmare. Therefore, we create a number of directories in the main directory of our project and move the related files inside it. Our CMakeLists.txt file might look similar to this:

\begin{lstlisting}[style=styleCMake]
# chapter03/01-partition/CMakeLists.txt

cmake_minimum_required(VERSION 3.20.0)
project(Rental CXX)
add_executable(Rental
				main.cpp
				cars/car.cpp
				# more files in other directories
)
\end{lstlisting}

That's all great, but as you can see, we still have the list of source files from the nested directory in a top-level file! To increase the separation of concerns, we could put the list of sources in another listfile and use the aforementioned include() command with a cars\_sources variable, like so:

\begin{lstlisting}[style=styleCMake]
# chapter03/02-include/CMakeLists.txt

cmake_minimum_required(VERSION 3.20.0)
project(Rental CXX)
include(cars/cars.cmake)
add_executable(Rental
				main.cpp
				${cars_sources}
				# ${more variables}
)
\end{lstlisting}

The new nested listfile would contain the sources:

\begin{lstlisting}[style=styleCMake]
# chapter03/02-include/cars/cars.cmake

set(cars_sources
	cars/car.cpp
	# cars/car_maintenance.cpp
)
\end{lstlisting}

CMake would effectively set cars\_sources in the same scope as add\_executable, filling the variable with all of the files. This solution works, but it has a few flaws:

\begin{itemize}
\item 
The variables from the nested directory will pollute the top-level scope (and vice versa): 

While it's not an issue in a simple example, in more complex, multi-level trees with multiple variables used in the process, it can quickly become a hard-to-debug problem.

\item 
All of the directories will share the same configuration:

This issue shows its true colors as projects mature over the years. Without any granularity, we have to treat every translation unit the same, and we cannot specify different compilation flags, choose a newer language version for some parts of the code, and silence warnings in chosen areas of the code. Everything is global, meaning that we need to introduce changes to all of the source files at the same time.

\item 
There are shared compilation triggers:

Any changes to the configuration will mean that all of the files will have to be recompiled, even if the change is meaningless for some of them.

\item 
All of the paths are relative to the top-level:

Note that in cars.cmake, we had to provide a full path to the cars/car.cpp file. This results in a lot of repeated text ruining the readability and going against the Don't Repeat Yourself (DRY) principle of clean coding. Renaming a directory would be a struggle.
\end{itemize}

The alternative is to use the add\_subdirectory() command, which introduces a variable scope and more. Let's take a look.

\subsubsubsection{3.3.1\hspace{0.2cm}Scoped subdirectories}

It's a common practice to structure your project following the natural structure of the filesystem, where nested directories represent the discrete elements of the application: the business logic, GUI, API, and reporting, and finally, separate directories with tests, external dependencies, scripts, and documentation. To support this concept, CMake offers the following command:

\begin{lstlisting}[style=styleCMake]
add_subdirectory(source_dir [binary_dir]
  [EXCLUDE_FROM_ALL])
\end{lstlisting}

As already established, this adds a source directory to our build. Optionally, we may provide a path in which built files will be written (binary\_dir). The EXCLUDE\_FROM\_ALL keyword will disable the default building of targets defined in the subdirectory (we'll cover targets in the next chapter). This may be useful for separating parts of the project that aren't needed for the core functionality (for example, examples and extensions).

This command will look for a CMakeLists.txt file in the source\_dir path (evaluated relative to the current directory). This file will then be parsed in the directory scope, meaning that all the flaws mentioned in the previous method aren't present:

\begin{itemize}
\item 
Variable changes are isolated to the nested scope.

\item 
You're free to configure the nested artifacts however you like.

\item 
Changing the nested CMakeLists.txt file doesn't require building unrelated targets.

\item 
Paths are local to the directory, and they can even be added to the parent include path if desired.
\end{itemize}

Let's take a look at a project with add\_subdirectory():

\begin{tcblisting}{commandshell={}}
chapter03/03-add_subdirectory# tree -A
.
├── CMakeLists.txt
├── cars
│     ├── CMakeLists.txt
│     ├── car.cpp
│     └── car.h
└── main.cpp
\end{tcblisting}

Here, we have two CMakeLists.txt files. The top-level file will use the nested directory, cars:

\begin{lstlisting}[style=styleCMake]
# chapter03/02-add_subdirectory/CMakeLists.txt

cmake_minimum_required(VERSION 3.20.0)
project(Rental CXX)

add_executable(Rental main.cpp)

add_subdirectory(cars)
target_link_libraries(Rental PRIVATE cars)
\end{lstlisting}

The last line is used to link the artifacts from the cars directory to the Rental executable. It is a target-specific command, which we'll discuss in depth in the next chapter. Let's see what the nested listfile looks like:

\begin{lstlisting}[style=styleCMake]
#chapter03/02-add_subdirectory/cars/CMakeLists.txt

add_library(cars OBJECT
	car.cpp
# car_maintenance.cpp
)
target_include_directories(cars PUBLIC .)
\end{lstlisting}

As you can see, I have used add\_library() to produce a globally visible target, cars, and added the cars directory to its public include directories with target\_include\_ directories(). This allows main.cpp to include the cars.h file without providing a relative path:

\begin{lstlisting}[style=styleCXX]
#include "car.h"
\end{lstlisting}

We can see the add\_library() command in the nested listfile, so did we start working with libraries in this example? Actually, no. Since we used the OBJECT keyword, we're indicating we're only interested in producing the object files (exactly as we did in the previous example). We just grouped them under a single logical target (cars). You may already have a sense of what a target is. Hold that thought – we'll get there in a second.

\subsubsubsection{3.3.2\hspace{0.2cm}Nested projects}

In the previous section, we briefly mentioned the EXCLUDE\_FROM\_ALL argument used in the add\_subdirectory() command. The CMake documentation suggests that if we have such parts living inside the source tree, they should have their own project() commands in their CMakeLists.txt files so that they can generate their own buildsystems and can be built independently.

Are there any other scenarios where this would be useful? Sure. For example, one scenario would be when you're working with multiple C++ projects built in one CI/CD pipeline (perhaps when building a framework or a set of libraries). Alternatively, maybe you're porting the buildsystem from a legacy solution, such as GNU Make, which uses plain makefiles. In such a case, you might want an option to slowly break things down into more independent pieces – possibly to put them in a separate build pipeline, or just to work on a smaller scope, which could be loaded by an IDE such as CLion.

You can achieve that by adding the project() command to the listfile in the nested directory. Just don't forget to prepend it with cmake\_minimum\_required().

Since project nesting is supported, could we somehow connect related projects that are built side by side?

\subsubsubsection{3.3.3\hspace{0.2cm}External projects}

It is technically possible to reach from one project to another, and CMake will support that to some extent. There's even a load\_cache() command that allows you to load values from another project's cache. That said, this isn't a regular or a recommended use case, and it will lead to issues with cyclical dependencies and project coupling. It's best to avoid this command and make a decision: should our related projects be nested, connected through libraries, or merged into a single project?

These are the partitioning tools at our disposal: including listfiles, adding subdirectories, and nesting projects. But how should we use them so our projects stay maintainable and easy to navigate and extend? To do this, we need a well-defined project structure.